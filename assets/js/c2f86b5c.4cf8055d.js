"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8456],{17218:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>f,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var i=e(85893),_=e(11151);const a={sidebar_position:3},r="\u5e38\u89c1\u95ee\u9898",o={id:"V851S/part1/01-3_SomeQustion",title:"\u5e38\u89c1\u95ee\u9898",description:"1.\u7f16\u8bd1\u6267\u884cmake\u65f6\u62a5\u6587\u4ef6\u7cfb\u7edf\u6743\u9650\u4e0d\u591f\u7684\u95ee\u9898",source:"@site/docs/V851S/part1/01-3_SomeQustion.md",sourceDirName:"V851S/part1",slug:"/V851S/part1/01-3_SomeQustion",permalink:"/docs/V851S/part1/01-3_SomeQustion",draft:!1,unlisted:!1,editUrl:"https://github.com/100askTeam/AllwinnerVisionIC-Docs/tree/main/docs/V851S/part1/01-3_SomeQustion.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"v851SSidebar",previous:{title:"\u66f4\u65b0\u7cfb\u7edf\u56fa\u4ef6",permalink:"/docs/V851S/part1/01-2_FlashSystem"},next:{title:"\u6700\u5c0f\u7cfb\u7edf\u5feb\u901f\u4e0a\u624b",permalink:"/docs/category/\u6700\u5c0f\u7cfb\u7edf\u5feb\u901f\u4e0a\u624b"}},f={},p=[{value:"1.\u7f16\u8bd1\u6267\u884cmake\u65f6\u62a5\u6587\u4ef6\u7cfb\u7edf\u6743\u9650\u4e0d\u591f\u7684\u95ee\u9898",id:"1\u7f16\u8bd1\u6267\u884cmake\u65f6\u62a5\u6587\u4ef6\u7cfb\u7edf\u6743\u9650\u4e0d\u591f\u7684\u95ee\u9898",level:2},{value:"2.\u6253\u5305pack\u65f6\u63d0\u793a\u6587\u4ef6\u7cfb\u7edf\u5927\u5c0f\u592a\u5927",id:"2\u6253\u5305pack\u65f6\u63d0\u793a\u6587\u4ef6\u7cfb\u7edf\u5927\u5c0f\u592a\u5927",level:2},{value:"3.\u5f00\u53d1\u677f\u542f\u52a8\u65f6\uff0c\u542f\u52a8nand\u5931\u8d25",id:"3\u5f00\u53d1\u677f\u542f\u52a8\u65f6\u542f\u52a8nand\u5931\u8d25",level:2}];function s(t){const n={code:"code",h1:"h1",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,_.a)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"\u5e38\u89c1\u95ee\u9898",children:"\u5e38\u89c1\u95ee\u9898"}),"\n",(0,i.jsx)(n.h2,{id:"1\u7f16\u8bd1\u6267\u884cmake\u65f6\u62a5\u6587\u4ef6\u7cfb\u7edf\u6743\u9650\u4e0d\u591f\u7684\u95ee\u9898",children:"1.\u7f16\u8bd1\u6267\u884cmake\u65f6\u62a5\u6587\u4ef6\u7cfb\u7edf\u6743\u9650\u4e0d\u591f\u7684\u95ee\u9898"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"==================================================\ntarget/allwinner/v851s-lizard/tina_busybox-init-basefiles.mk is called to generate shell scripts\n==================================================\n(/home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard/busybox-init-base-files_generate/rootfs_hook_squash.sh /home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard/busybox-init-base-files >/dev/null) || { \\\n\techo \"Execute the /home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard/busybox-init-base-files_generate/rootfs_hook_squash.sh is failed\"; \\\n\texit 1; \\\n}\n/bin/sh: 1: /home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard/busybox-init-base-files_generate/rootfs_hook_squash.sh: Permission denied\nExecute the /home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard/busybox-init-base-files_generate/rootfs_hook_squash.sh is failed\ntina_busybox-init-base-files.mk:14: recipe for target 'all' failed\nmake[4]: *** [all] Error 1\nmake[4]: Leaving directory '/home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard'\nMakefile:228: recipe for target '/home/book/workspace/tina-v853/out/v851s/lizard/openwrt/build_dir/target/linux-v851s-lizard/busybox-init-base-files/.built' failed\nmake[3]: *** [/home/book/workspace/tina-v853/out/v851s/lizard/openwrt/build_dir/target/linux-v851s-lizard/busybox-init-base-files/.built] Error 2\nmake[3]: Leaving directory '/home/book/workspace/tina-v853/openwrt/package/allwinner/system/busybox-init-base-files'\ntime: package/subpackage/allwinner/system/busybox-init-base-files/compile#0.32#0.25#0.55\n    ERROR: package/subpackage/allwinner/system/busybox-init-base-files failed to build.\npackage/Makefile:114: recipe for target 'package/subpackage/allwinner/system/busybox-init-base-files/compile' failed\nmake[2]: *** [package/subpackage/allwinner/system/busybox-init-base-files/compile] Error 1\nmake[2]: Leaving directory '/home/book/workspace/tina-v853/openwrt/openwrt'\npackage/Makefile:110: recipe for target '/home/book/workspace/tina-v853/openwrt/openwrt/staging_dir/target/stamp/.package_compile' failed\nmake[1]: *** [/home/book/workspace/tina-v853/openwrt/openwrt/staging_dir/target/stamp/.package_compile] Error 2\nmake[1]: Leaving directory '/home/book/workspace/tina-v853/openwrt/openwrt'\n/home/book/workspace/tina-v853/openwrt/openwrt/include/toplevel.mk:236: recipe for target 'world' failed\nmake: *** [world] Error 2\nmake: Leaving directory '/home/book/workspace/tina-v853/openwrt/openwrt'\nINFO: build_openwrt_rootfs failed\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u89e3\u51b3\u529e\u6cd5\u662f\u6309\u5982\u4e0b\u65b9\u5f0f\u589e\u52a0\u6587\u4ef6\u6743\u9650"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"book@100ask:~/workspace/tina-v853$ chmod 755 /home/book/workspace/tina-v853/openwrt/target/v851s/v851s-lizard/busybox-init-base-files_generate/mk_extra_dir.sh\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2\u6253\u5305pack\u65f6\u63d0\u793a\u6587\u4ef6\u7cfb\u7edf\u5927\u5c0f\u592a\u5927",children:"2.\u6253\u5305pack\u65f6\u63d0\u793a\u6587\u4ef6\u7cfb\u7edf\u5927\u5c0f\u592a\u5927"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"ERROR: dl file rootfs.fex size too large\nERROR: filename = rootfs.fex\nERROR: dl_file_size = 53760 sector\nERROR: part_size = 45360 sector\nupdate_for_part_info -1\nERROR: update mbr file fail\nERROR: update_mbr failed\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u539f\u672c\u7684part_size\u7684\u503c\u4e3a45360\uff0c\u9700\u8981\u4fee\u6539\u6210dl_file_size\u7684\u503c53760"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"book@100ask:~/tina-v853$ vim device/config/chips/v851s/configs/lizard/linux-4.9/sys_partition.fex\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/dongshanpi-docs/YuzukiHD-Lizard/YuzukiHD-Lizard-03-2-Question-1.png",alt:"YuzukiHD-Lizard-03-2-Question-1"})}),"\n",(0,i.jsx)(n.h2,{id:"3\u5f00\u53d1\u677f\u542f\u52a8\u65f6\u542f\u52a8nand\u5931\u8d25",children:"3.\u5f00\u53d1\u677f\u542f\u52a8\u65f6\uff0c\u542f\u52a8nand\u5931\u8d25"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'[    4.087239]\n[    4.087836] device_chose finished 122!\n[    4.133404] Please append a correct "root=" boot option; here are the available partitions:\n[    4.142801] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n[    4.152057] CPU: 0 PID: 1 Comm: swapper Not tainted 4.9.191 #1\n[    4.158582] Hardware name: sun8iw21\n[    4.162517] [<c010d5a0>] (unwind_backtrace) from [<c010a694>] (show_stack+0x10/0x14)\n[    4.171192] [<c010a694>] (show_stack) from [<c017050c>] (panic+0xac/0x2b8)\n[    4.178899] [<c017050c>] (panic) from [<c09012cc>] (mount_block_root+0x258/0x300)\n[    4.187284] [<c09012cc>] (mount_block_root) from [<c0901500>] (prepare_namespace+0x118/0x178)\n[    4.196834] [<c0901500>] (prepare_namespace) from [<c0900eb4>] (kernel_init_freeable+0x144/0x178)\n[    4.206771] [<c0900eb4>] (kernel_init_freeable) from [<c067464c>] (kernel_init+0x8/0x118)\n[    4.215932] [<c067464c>] (kernel_init) from [<c0106e08>] (ret_from_fork+0x14/0x2c)\n[    4.224410] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n[    4.234532] sunxi dump enabled\n[    4.237944] dump regs done\n[    4.241001] flush cache done\n[    4.244239] crashdump enter\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u5728/tina-v853/kernel/linux-4.9/drivers/mtd/awnand/spinand/physic/\u76ee\u5f55\u4e0b\uff0c\u5c06\u6211\u4eec\u63d0\u4f9b\u7684id.c\u6587\u4ef6\u66ff\u6362\u539f\u672c\u76ee\u5f55\u4e2d\u7684id.c\u6587\u4ef6\u3002id.c\u6587\u4ef6\u5185\u5bb9\u4e3a\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// SPDX-License-Identifier: GPL-2.0\n\n#define pr_fmt(fmt) "sunxi-spinand-phy: " fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/aw-spinand.h>\n#include <linux/of.h>\n\n#include "physic.h"\n\n#define KB (1024)\n#define MB (KB * 1024)\n#define to_kb(size) (size / KB)\n#define to_mb(size) (size / MB)\n\n/* manufacture num */\n#define MICRON_MANUFACTURE\t0x2c\n#define GD_MANUFACTURE\t\t0xc8\n#define ATO_MANUFACTURE\t\t0x9b\n#define WINBOND_MANUFACTURE\t0xef\n#define MXIC_MANUFACTURE\t0xc2\n#define TOSHIBA_MANUFACTURE\t0x98\n#define ETRON_MANUFACTURE\t0xd5\n#define XTXTECH_MANUFACTURE\t0x0b\n#define DSTECH_MANUFACTURE\t0xe5\n#define FORESEE_MANUFACTURE\t0xcd\n#define ZETTA_MANUFACTURE\t0xba\n#define FM_MANUFACTURE\t\t0xa1\n\nstruct spinand_manufacture m;\n\nstruct aw_spinand_phy_info gigadevice[] = {\n\t{\n\t\t.Model\t\t= "GD5F1GQ4UCYIG",\n\t\t.NandID\t\t= {0xc8, 0xb1, 0x48, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ | SPINAND_ONEDUMMY_AFTER_RANDOMREAD,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccType\t= BIT3_LIMIT2_TO_6_ERR7,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "GD5F1GQ4UBYIG",\n\t\t.NandID\t\t= {0xc8, 0xd1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccFlag\t= HAS_EXT_ECC_SE01,\n\t\t.EccType\t= BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN8_OFF4,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t/* GD5F2GQ4UB9IG did not check yet */\n\t\t.Model\t\t= "GD5F2GQ4UB9IG",\n\t\t.NandID\t\t= {0xc8, 0xd2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 2048,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccFlag\t= HAS_EXT_ECC_SE01,\n\t\t.EccType\t= BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN12,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t.Model    = "GD5F1GQ5UEYIG",\n\t\t.NandID    = {0xc8, 0x51, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie  = 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt  = SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccFlag  = HAS_EXT_ECC_SE01,\n\t\t.EccType  = BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN12,\n\t\t.BadBlockFlag  = BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "F50L1G41LB(2M)",\n\t\t.NandID\t\t= {0xc8, 0x01, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ | SPINAND_QUAD_NO_NEED_ENABLE,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN4_OFF8,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FIRST_2_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "GD5F2GM7UEYI",\n\t\t.NandID\t\t= {0xc8, 0x92, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 2048,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccFlag\t= HAS_EXT_ECC_SE01,\n\t\t.EccType\t= BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info micron[] = {\n\t{\n\t\t.Model\t\t= "MT29F1G01ABAGDWB",\n\t\t.NandID\t\t= {0x2c, 0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ | SPINAND_QUAD_NO_NEED_ENABLE,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccType\t= BIT3_LIMIT5_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF32_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "MT29F2G01ABAGDWB",\n\t\t.NandID\t\t= {0x2c, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 2048,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ | SPINAND_QUAD_NO_NEED_ENABLE,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccType\t= BIT3_LIMIT5_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF32_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info xtx[] = {\n\t{\n\t\t/* XTX26G02A */\n\t\t.Model\t\t= "XTX26G02A",\n\t\t.NandID\t\t= {0x0B, 0xE2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 2048,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.ecc_status_shift = ECC_STATUS_SHIFT_2,\n\t\t.EccType\t= BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF8_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t/* XTX26G02A */\n\t\t.Model\t\t= "XTX26G01A",\n\t\t.NandID\t\t= {0x0B, 0xE1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.ecc_status_shift = ECC_STATUS_SHIFT_2,\n\t\t.EccType\t= BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF8_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t/* XT26G01C */\n\t\t.Model\t\t= "XT26G01C",\n\t\t.NandID\t\t= {0x0B, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.ecc_status_shift = ECC_STATUS_SHIFT_4,\n\t\t.EccType\t= BIT4_LIMIT5_TO_8_ERR9_TO_15,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t/* XT26G02C */\n\t\t.Model\t\t= "XT26G02CWSIG",\n\t\t.NandID\t\t= {0x0B, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 2048,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_DUAL_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.ecc_status_shift = ECC_STATUS_SHIFT_2,\n\t\t.EccType\t= BIT4_LIMIT5_TO_7_ERR8_LIMIT_12,\n\t\t.EccProtectedType = SIZE16_OFF8_LEN16,\n\t\t.BadBlockFlag\t= BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info fm[] = {\n\t{\n\t\t/* only rw stress test */\n\t\t.Model\t\t= "FM25S01",\n\t\t.NandID\t\t= {0xa1, 0xa1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ | SPINAND_QUAD_NO_NEED_ENABLE,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FIRST_2_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info etron[] = {\n\n};\n\nstruct aw_spinand_phy_info toshiba[] = {\n\n};\n\nstruct aw_spinand_phy_info ato[] = {\n\n};\n\nstruct aw_spinand_phy_info mxic[] = {\n\t{\n\t\t.Model\t\t= "MX35LF1GE4AB",\n\t\t.NandID\t\t= {0xc2, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccFlag\t= HAS_EXT_ECC_STATUS,\n\t\t.EccType\t= BIT4_LIMIT3_TO_4_ERR15,\n\t\t/**\n\t\t * MX35LF1GE4AB should use SIZE16_OFF4_LEN12, however, in order\n\t\t * to compatibility with versions already sent to customers,\n\t\t * which do not use general physical layout, we used\n\t\t * SIZE16_OFF4_LEN4_OFF8 instead.\n\t\t */\n\t\t.EccProtectedType = SIZE16_OFF4_LEN4_OFF8,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FIRST_2_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "MX35LF2GE4AD",\n\t\t.NandID\t\t= {0xc2, 0x26, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 2048,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccFlag\t= HAS_EXT_ECC_STATUS,\n\t\t.EccType\t= BIT4_LIMIT5_TO_8_ERR9_TO_15,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN4_OFF8,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FIRST_2_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info winbond[] = {\n\t{\n\t\t.Model\t\t= "W25N01GVZEIG",\n\t\t.NandID\t\t= {0xef, 0xaa, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN4_OFF8,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info dosilicon[] = {\n\t{\n\t\t.Model\t\t= "DS35X1GAXXX",\n\t\t.NandID\t\t= {0xe5, 0x71, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 65000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN4_OFF8,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FIRST_2_PAGE,\n\t},\n};\n\nstruct aw_spinand_phy_info foresee[] = {\n\t{\n\t\t.Model\t\t= "FS35ND01G-S1F1QWFI000",\n\t\t.NandID\t\t= {0xcd, 0xb1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccType\t= BIT3_LIMIT3_TO_4_ERR7,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "FS35ND01G-S1Y2QWFI000",\n\t\t.NandID\t\t= {0xcd, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FRIST_1_PAGE,\n\t},\n\t{\n\t\t.Model\t\t= "FS35SQA001G",\n\t\t.NandID\t\t= {0xcd, 0x71, 0x71, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF0_LEN16,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FRIST_1_PAGE,\n\t}\n};\n\nstruct aw_spinand_phy_info zetta[] = {\n\t{\n\t\t.Model\t\t= "ZD35Q1GAIB",\n\t\t.NandID\t\t= {0xba, 0x71, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t.DieCntPerChip  = 1,\n\t\t.SectCntPerPage = 4,\n\t\t.PageCntPerBlk  = 64,\n\t\t.BlkCntPerDie\t= 1024,\n\t\t.OobSizePerPage = 64,\n\t\t.OperationOpt\t= SPINAND_QUAD_READ | SPINAND_QUAD_PROGRAM |\n\t\t\tSPINAND_DUAL_READ,\n\t\t.MaxEraseTimes  = 50000,\n\t\t.EccType\t= BIT2_LIMIT1_ERR2,\n\t\t.EccProtectedType = SIZE16_OFF4_LEN4_OFF8,\n\t\t.BadBlockFlag = BAD_BLK_FLAG_FIRST_2_PAGE,\n\t},\n};\n\nstatic const char *aw_spinand_info_model(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->Model;\n}\n\nstatic void aw_spinand_info_nandid(struct aw_spinand_chip *chip,\n\t\tunsigned char *id, int cnt)\n{\n\tint i;\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\tcnt = min(cnt, MAX_ID_LEN);\n\tfor (i = 0; i < cnt; i++)\n\t\tid[i] = pinfo->NandID[i];\n}\n\nstatic unsigned int aw_spinand_info_sector_size(struct aw_spinand_chip *chip)\n{\n\treturn 1 << SECTOR_SHIFT;\n}\n\nstatic unsigned int aw_spinand_info_phy_page_size(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->SectCntPerPage * aw_spinand_info_sector_size(chip);\n}\n\nstatic unsigned int aw_spinand_info_page_size(struct aw_spinand_chip *chip)\n{\n#if IS_ENABLED(CONFIG_AW_SPINAND_SIMULATE_MULTIPLANE)\n\treturn aw_spinand_info_phy_page_size(chip) * 2;\n#else\n\treturn aw_spinand_info_phy_page_size(chip);\n#endif\n}\n\nstatic unsigned int aw_spinand_info_phy_block_size(\n\t\tstruct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->PageCntPerBlk * aw_spinand_info_phy_page_size(chip);\n}\n\nstatic unsigned int aw_spinand_info_block_size(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->PageCntPerBlk * aw_spinand_info_page_size(chip);\n}\n\nstatic unsigned int aw_spinand_info_phy_oob_size(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->OobSizePerPage;\n}\n\nstatic unsigned int aw_spinand_info_oob_size(struct aw_spinand_chip *chip)\n{\n#if IS_ENABLED(CONFIG_AW_SPINAND_SIMULATE_MULTIPLANE)\n\treturn aw_spinand_info_phy_oob_size(chip) * 2;\n#else\n\treturn aw_spinand_info_phy_oob_size(chip);\n#endif\n}\n\nstatic unsigned int aw_spinand_info_die_cnt(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->DieCntPerChip;\n}\n\nstatic unsigned int aw_spinand_info_total_size(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->DieCntPerChip * pinfo->BlkCntPerDie *\n\t\taw_spinand_info_phy_block_size(chip);\n}\n\nstatic int aw_spinand_info_operation_opt(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->OperationOpt;\n}\n\nstatic int aw_spinand_info_max_erase_times(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo = chip->info->phy_info;\n\n\treturn pinfo->MaxEraseTimes;\n}\n\nstruct spinand_manufacture {\n\tunsigned char id;\n\tconst char *name;\n\tstruct aw_spinand_phy_info *info;\n\tunsigned int cnt;\n};\n\n#define SPINAND_FACTORY_INFO(_id, _name, _info)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.info = _info,\t\t\t\t\t\\\n\t\t.cnt = ARRAY_SIZE(_info),\t\t\t\\\n\t}\nstatic struct spinand_manufacture spinand_factory[] = {\n\tSPINAND_FACTORY_INFO(MICRON_MANUFACTURE, "Micron", micron),\n\tSPINAND_FACTORY_INFO(GD_MANUFACTURE, "GD", gigadevice),\n\tSPINAND_FACTORY_INFO(ATO_MANUFACTURE, "ATO", ato),\n\tSPINAND_FACTORY_INFO(WINBOND_MANUFACTURE, "Winbond", winbond),\n\tSPINAND_FACTORY_INFO(MXIC_MANUFACTURE, "Mxic", mxic),\n\tSPINAND_FACTORY_INFO(TOSHIBA_MANUFACTURE, "Toshiba", toshiba),\n\tSPINAND_FACTORY_INFO(ETRON_MANUFACTURE, "Etron", etron),\n\tSPINAND_FACTORY_INFO(XTXTECH_MANUFACTURE, "XTX", xtx),\n\tSPINAND_FACTORY_INFO(DSTECH_MANUFACTURE, "Dosilicon", dosilicon),\n\tSPINAND_FACTORY_INFO(FORESEE_MANUFACTURE, "Foresee", foresee),\n\tSPINAND_FACTORY_INFO(ZETTA_MANUFACTURE, "Zetta", zetta),\n\tSPINAND_FACTORY_INFO(FM_MANUFACTURE, "FM", fm),\n};\n\n\nstatic int spinand_get_chip_munufacture(struct aw_spinand_chip *chip, const char **m)\n{\n\tstruct aw_spinand_phy_info *info = chip->info->phy_info;\n\n\tswitch (info->NandID[0]) {\n\tcase MICRON_MANUFACTURE:\n\t\t*m = "Micron";\n\tbreak;\n\tcase GD_MANUFACTURE:\n\t\t*m = "GD";\n\tbreak;\n\tcase ATO_MANUFACTURE:\n\t\t*m = "ATO";\n\tbreak;\n\tcase WINBOND_MANUFACTURE:\n\t\t*m = "Winbond";\n\tbreak;\n\tcase MXIC_MANUFACTURE:\n\t\t*m = "Mxic";\n\tbreak;\n\tcase TOSHIBA_MANUFACTURE:\n\t\t*m = "Toshiba";\n\tbreak;\n\tcase ETRON_MANUFACTURE:\n\t\t*m = "Etron";\n\tbreak;\n\tcase XTXTECH_MANUFACTURE:\n\t\t*m = "XTX";\n\tbreak;\n\tcase DSTECH_MANUFACTURE:\n\t\t*m = "Dosilicon";\n\tbreak;\n\tcase FORESEE_MANUFACTURE:\n\t\t*m = "Foresee";\n\tbreak;\n\tcase ZETTA_MANUFACTURE:\n\t\t*m = "Zetta";\n\tbreak;\n\tdefault:\n\t\t*m = NULL;\n\tbreak;\n\t}\n\n\tif (*m == NULL)\n\t\treturn false;\n\telse\n\t\treturn true;\n\n}\nstatic const char *aw_spinand_info_manufacture(struct aw_spinand_chip *chip)\n{\n\tint i, j;\n\tstruct spinand_manufacture *m;\n\tstruct aw_spinand_phy_info *pinfo;\n\tconst char *m_name = NULL;\n\tint ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(spinand_factory); i++) {\n\t\tm = &spinand_factory[i];\n\t\tpinfo = chip->info->phy_info;\n\t\tfor (j = 0; j < m->cnt; j++)\n\t\t\tif (pinfo == &m->info[j])\n\t\t\t\treturn m->name;\n\t}\n\n\t/*for compatible fdt support spi-nand*/\n\tret = spinand_get_chip_munufacture(chip, &m_name);\n\tif (ret < 0)\n\t\treturn NULL;\n\telse\n\t\treturn m_name;\n}\n\nstatic struct spinand_manufacture *spinand_detect_munufacture(unsigned char id)\n{\n\tint index;\n\tstruct spinand_manufacture *m;\n\n\tfor (index = 0; index < ARRAY_SIZE(spinand_factory); index++) {\n\t\tm = &spinand_factory[index];\n\t\tif (m->id == id) {\n\t\t\tpr_info("detect munufacture from id table: %s\\n", m->name);\n\t\t\treturn m;\n\t\t}\n\t}\n\n\tpr_err("not detect any munufacture from id table\\n");\n\treturn NULL;\n}\n\nstatic struct aw_spinand_phy_info *spinand_match_id(\n\t\tstruct spinand_manufacture *m,\n\t\tunsigned char *id)\n{\n\tint i, j, match_max = 1, match_index = 0;\n\tstruct aw_spinand_phy_info *pinfo;\n\n\tfor (i = 0; i < m->cnt; i++) {\n\t\tint match = 1;\n\n\t\tpinfo = &m->info[i];\n\t\tfor (j = 1; j < MAX_ID_LEN; j++) {\n\t\t\t/* 0xFF matching all ID value */\n\t\t\tif (pinfo->NandID[j] != id[j] &&\n\t\t\t\t\tpinfo->NandID[j] != 0xFF)\n\t\t\t\tbreak;\n\n\t\t\tif (pinfo->NandID[j] != 0xFF)\n\t\t\t\tmatch++;\n\t\t}\n\n\t\tif (match > match_max) {\n\t\t\tmatch_max = match;\n\t\t\tmatch_index = i;\n\t\t}\n\t}\n\n\tif (match_max > 1)\n\t\treturn &m->info[match_index];\n\treturn NULL;\n}\n\nstruct aw_spinand_phy_info *spinand_get_phy_info_from_fdt(struct aw_spinand_chip *chip)\n{\n\tstatic struct aw_spinand_phy_info info;\n\tstatic int had_get;\n\tint ret = 0;\n\tconst char *bad_blk_mark_pos = NULL;\n\tconst char *quad_read_not_need_enable = NULL;\n\tconst char *read_seq_need_onedummy = NULL;\n\tint len = 0;\n\tu32 id = 0xffffffff;\n\tstruct device_node *node = chip->spi->dev.of_node;\n\tu32 rx_bus_width = 0;\n\tu32 tx_bus_width = 0;\n\n\n\tif (had_get == true)\n\t\treturn &info;\n\n#define BAD_BLK_MARK_POS1 "first_1_page"\n#define BAD_BLK_MARK_POS2 "first_2_page"\n#define BAD_BLK_MARK_POS3 "last_1_page"\n#define BAD_BLK_MARK_POS4 "last_2_page"\n\tmemset(&info, 0, sizeof(struct aw_spinand_phy_info));\n\n\tret = of_property_read_string(node, "model", &(info.Model));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand Model from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "id-0", &id);\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand id Low 4 Byte from fdt fail\\n");\n\t\tgoto err;\n\t}\n\tlen = sizeof(id);\n\tmemmove(info.NandID, &id, min(MAX_ID_LEN, len));\n\n\tid = 0xffffffff;\n\tret = of_property_read_u32(node, "id-1", &id);\n\tif (ret < 0) {\n\t\tpr_info("can\'t get spi-nand id high 4 Byte from fdt, may be not need\\n");\n\t}\n\tmemmove(info.NandID + min(MAX_ID_LEN, len), &id, max(MAX_ID_LEN, len) - min(MAX_ID_LEN, len));\n\n\tret = of_property_read_u32(node, "die_cnt_per_chip", &(info.DieCntPerChip));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand DieCntPerChip from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "blk_cnt_per_die", &(info.BlkCntPerDie));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand BlkCntPerDie from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "page_cnt_per_blk", &(info.PageCntPerBlk));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand PageCntPerBlk from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "sect_cnt_per_page", &(info.SectCntPerPage));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand SectCntPerPage from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "oob_size_per_page", &(info.OobSizePerPage));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand OobSizePerPage from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_string(node, "bad_block_mark_pos", &bad_blk_mark_pos);\n\tif (ret < 0 || NULL == bad_blk_mark_pos) {\n\t\tpr_err("get spi-nand BadBlockFlag from fdt fail\\n");\n\t\tgoto err;\n\t} else {\n\t\tif (!memcmp(bad_blk_mark_pos, BAD_BLK_MARK_POS1, strlen(BAD_BLK_MARK_POS1)))\n\t\t\tinfo.BadBlockFlag = BAD_BLK_FLAG_FRIST_1_PAGE;\n\t\telse if (!memcmp(bad_blk_mark_pos, BAD_BLK_MARK_POS2, strlen(BAD_BLK_MARK_POS2)))\n\t\t\tinfo.BadBlockFlag = BAD_BLK_FLAG_FRIST_1_PAGE;\n\t\telse if (!memcmp(bad_blk_mark_pos, BAD_BLK_MARK_POS3, strlen(BAD_BLK_MARK_POS3)))\n\t\t\tinfo.BadBlockFlag = BAD_BLK_FLAG_LAST_1_PAGE;\n\t\telse if (!memcmp(bad_blk_mark_pos, BAD_BLK_MARK_POS4, strlen(BAD_BLK_MARK_POS4)))\n\t\t\tinfo.BadBlockFlag = BAD_BLK_FLAG_LAST_2_PAGE;\n\t\telse {\n\t\t\tpr_err("get spi-nand BadBlockFlag pattern is not right\\n");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = of_property_read_s32(node, "max_erase_times", &(info.MaxEraseTimes));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand MaxEraseTimes from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "ecc_type", &(info.EccType));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand EccFlag from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "ecc_protected_type", &(info.EccProtectedType));\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand ecc_protected_type from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(node, "spi-rx-bus-width", &rx_bus_width);\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand spi-rx-bus-width from fdt fail\\n");\n\t\tgoto err;\n\t} else {\n\t\tswitch (rx_bus_width) {\n\t\tcase SPI_NBITS_DUAL:\n\t\t\tinfo.OperationOpt |= SPINAND_DUAL_READ;\n\t\tbreak;\n\t\tcase SPI_NBITS_QUAD:\n\t\t\tinfo.OperationOpt |= SPINAND_QUAD_READ;\n\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.OperationOpt |= 0;\n\t\tbreak;\n\t\t}\n\t}\n\n\tret = of_property_read_u32(node, "spi-tx-bus-width", &tx_bus_width);\n\tif (ret < 0) {\n\t\tpr_err("get spi-nand spi-tx-bus-width from fdt fail\\n");\n\t\tgoto err;\n\t} else {\n\t\tswitch (tx_bus_width) {\n\t\tcase SPI_NBITS_QUAD:\n\t\t\tinfo.OperationOpt |= SPINAND_QUAD_PROGRAM;\n\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.OperationOpt |= 0;\n\t\tbreak;\n\t\t}\n\t}\n\n\tret = of_property_read_string(node, "read_from_cache_x4_not_need_enable",\n\t\t\t&quad_read_not_need_enable);\n\tpr_info("%d quad_read_not_need_enable:%s\\n", __LINE__, quad_read_not_need_enable);\n\tif (ret < 0 || NULL == quad_read_not_need_enable) {\n\t\tpr_info("can\'t get spi-nand read_from_cache_x4_need_enable or it is null,"\n\t\t\t\t" maybe not need enable quad read before read from cache x4\\n");\n\t} else {\n\t\tif (!memcmp(quad_read_not_need_enable, "yes", strlen("yes")))\n\t\t\tinfo.OperationOpt |= SPINAND_QUAD_NO_NEED_ENABLE;\n\t}\n\n\tret = of_property_read_string(node, "read_from_cache_need_onedummy",\n\t\t\t&read_seq_need_onedummy);\n\tif (ret < 0 || NULL == read_seq_need_onedummy) {\n\t\tpr_info("can\'t get spi-nand read_from_cache_need_onedummy or it is null,"\n\t\t\t\t" maybe read from cache sequence not need one dummy in second Byte\\n");\n\t} else {\n\t\tif (!memcmp(read_seq_need_onedummy, "yes", strlen("yes")))\n\t\t\tinfo.OperationOpt |= SPINAND_ONEDUMMY_AFTER_RANDOMREAD;\n\t}\n\n\n\tret = of_property_read_s32(node, "ecc_flag", &(info.EccFlag));\n\tif (ret < 0) {\n\t\tpr_err("can\'t get spi-nand EccFlag from fdt,"\n\t\t\t\t" maybe(default) use 0FH + C0H to get feature,wich obtain ecc status\\n");\n\t}\n\n\tret = of_property_read_u32(node, "ecc_status_shift", &(info.ecc_status_shift));\n\tif (ret < 0) {\n\t\tpr_info("can\'t get spi-nand ecc_status_shift from fdt,"\n\t\t\t\t" use default ecc_status_shift_4 to get ecc status in C0H\\n");\n\t}\n\n\tpr_debug("get spinand phy info from fdt\\n");\n\tpr_debug("Model:%s\\n", info.Model);\n\tpr_debug("ID:%02x %02x %02x %02x %02x %02x %02x %02x\\n",\n\t\t\tinfo.NandID[0], info.NandID[1], info.NandID[2], info.NandID[3],\n\t\t\tinfo.NandID[4], info.NandID[5], info.NandID[6], info.NandID[7]);\n\tpr_debug("DieCntPerChip:%d\\n", info.DieCntPerChip);\n\tpr_debug("BlkCntPerDie:%d\\n", info.BlkCntPerDie);\n\tpr_debug("PageCntPerBlk:%d\\n", info.PageCntPerBlk);\n\tpr_debug("SectCntPerPage:%d\\n", info.SectCntPerPage);\n\tpr_debug("OobSizePerPage:%d\\n", info.OobSizePerPage);\n\tpr_debug("BadBlockFlag:%d\\n", info.BadBlockFlag);\n\tpr_debug("OperationOpt:0x%x\\n", info.OperationOpt);\n\tpr_debug("MaxEraseTimes:%d\\n", info.MaxEraseTimes);\n\tpr_debug("EccFlag:%x\\n", info.EccFlag);\n\tpr_debug("ecc_status_shift:%x\\n", info.ecc_status_shift);\n\tpr_debug("EccType:%x\\n", info.EccType);\n\tpr_debug("EccProtectedType:%x\\n", info.EccProtectedType);\n\n\thad_get = true;\n\n\treturn &info;\nerr:\n\thad_get = false;\n\treturn NULL;\n}\n\nstatic struct aw_spinand_info aw_spinand_info = {\n\t.model = aw_spinand_info_model,\n\t.manufacture = aw_spinand_info_manufacture,\n\t.nandid = aw_spinand_info_nandid,\n\t.die_cnt = aw_spinand_info_die_cnt,\n\t.oob_size = aw_spinand_info_oob_size,\n\t.page_size = aw_spinand_info_page_size,\n\t.block_size = aw_spinand_info_block_size,\n\t.phy_oob_size = aw_spinand_info_phy_oob_size,\n\t.phy_page_size = aw_spinand_info_phy_page_size,\n\t.phy_block_size = aw_spinand_info_phy_block_size,\n\t.sector_size = aw_spinand_info_sector_size,\n\t.total_size = aw_spinand_info_total_size,\n\t.operation_opt = aw_spinand_info_operation_opt,\n\t.max_erase_times = aw_spinand_info_max_erase_times,\n};\n\nstatic struct spinand_manufacture *spinand_detect_munufacture_from_fdt(struct aw_spinand_chip *chip, unsigned char id)\n{\n\tstruct aw_spinand_phy_info *info = NULL;\n\tstruct spinand_manufacture *pm = &m;\n\tint ret = 0;\n\n\tinfo = spinand_get_phy_info_from_fdt(chip);\n\tif (info == NULL) {\n\t\tpr_err("get phy info from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tif (id == info->NandID[0]) {\n\t\tpm->id = info->NandID[0];\n\t\tpm->info = info;\n\t\tchip->info = &aw_spinand_info;\n\t\tchip->info->phy_info = info;\n\t\tret = spinand_get_chip_munufacture(chip, &(pm->name));\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\telse\n\t\t\tpr_info("detect munufacture from fdt: %s \\n", pm->name);\n\t} else {\n\t\tgoto err;\n\t}\n\n\treturn pm;\nerr:\n\tpr_info("not detect munufacture from fdt\\n");\n\treturn NULL;\n}\n\nstatic struct aw_spinand_phy_info *spinand_match_id_from_fdt(struct aw_spinand_chip *chip,\n\t\tstruct spinand_manufacture *m,\n\t\tunsigned char *id)\n{\n\tstruct aw_spinand_phy_info *info = NULL;\n\tint i = 0;\n\n\tinfo = spinand_get_phy_info_from_fdt(chip);\n\tif (info == NULL) {\n\t\tpr_err("get phy info from fdt fail\\n");\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < MAX_ID_LEN; i++) {\n\t\t/*0xff match all id value*/\n\t\tif (id[i] != info->NandID[i] && info->NandID[i] != 0xff)\n\t\t\tgoto err;\n\t}\n\n\treturn info;\n\nerr:\n\treturn NULL;\n}\nstatic int aw_spinand_info_init(struct aw_spinand_chip *chip,\n\t\tstruct aw_spinand_phy_info *pinfo)\n{\n\tchip->info = &aw_spinand_info;\n\tchip->info->phy_info = pinfo;\n\n\tpr_info("========== arch info ==========\\n");\n\tpr_info("Model:               %s\\n", pinfo->Model);\n\tpr_info("Munufacture:         %s\\n", aw_spinand_info_manufacture(chip));\n\tpr_info("DieCntPerChip:       %u\\n", pinfo->DieCntPerChip);\n\tpr_info("BlkCntPerDie:        %u\\n", pinfo->BlkCntPerDie);\n\tpr_info("PageCntPerBlk:       %u\\n", pinfo->PageCntPerBlk);\n\tpr_info("SectCntPerPage:      %u\\n", pinfo->SectCntPerPage);\n\tpr_info("OobSizePerPage:      %u\\n", pinfo->OobSizePerPage);\n\tpr_info("BadBlockFlag:        0x%x\\n", pinfo->BadBlockFlag);\n\tpr_info("OperationOpt:        0x%x\\n", pinfo->OperationOpt);\n\tpr_info("MaxEraseTimes:       %d\\n", pinfo->MaxEraseTimes);\n\tpr_info("EccFlag:             0x%x\\n", pinfo->EccFlag);\n\tpr_info("EccType:             %d\\n", pinfo->EccType);\n\tpr_info("EccProtectedType:    %d\\n", pinfo->EccProtectedType);\n\tpr_info("========================================\\n");\n\tpr_info("\\n");\n\tpr_info("========== physical info ==========\\n");\n\tpr_info("TotalSize:    %u M\\n", to_mb(aw_spinand_info_total_size(chip)));\n\tpr_info("SectorSize:   %u B\\n", aw_spinand_info_sector_size(chip));\n\tpr_info("PageSize:     %u K\\n", to_kb(aw_spinand_info_phy_page_size(chip)));\n\tpr_info("BlockSize:    %u K\\n", to_kb(aw_spinand_info_phy_block_size(chip)));\n\tpr_info("OOBSize:      %u B\\n", aw_spinand_info_phy_oob_size(chip));\n\tpr_info("========================================\\n");\n\tpr_info("\\n");\n\tpr_info("========== logical info ==========\\n");\n\tpr_info("TotalSize:    %u M\\n", to_mb(aw_spinand_info_total_size(chip)));\n\tpr_info("SectorSize:   %u B\\n", aw_spinand_info_sector_size(chip));\n\tpr_info("PageSize:     %u K\\n", to_kb(aw_spinand_info_page_size(chip)));\n\tpr_info("BlockSize:    %u K\\n", to_kb(aw_spinand_info_block_size(chip)));\n\tpr_info("OOBSize:      %u B\\n", aw_spinand_info_oob_size(chip));\n\tpr_info("========================================\\n");\n\n\treturn 0;\n}\n\nint aw_spinand_chip_detect(struct aw_spinand_chip *chip)\n{\n\tstruct aw_spinand_phy_info *pinfo;\n\tstruct spinand_manufacture *m;\n\tunsigned char id[MAX_ID_LEN] = {0xFF};\n\tstruct aw_spinand_chip_ops *ops = chip->ops;\n\tint ret, dummy = 1;\n\nretry:\n\t/*first read with dummy/address@0x00*/\n\tret = ops->read_id(chip, id, MAX_ID_LEN, dummy);\n\tif (ret) {\n\t\tpr_err("read id failed : %d\\n", ret);\n\t\treturn ret;\n\t}\n\n\tm = spinand_detect_munufacture(id[0]);\n\tif (!m)\n\t\tgoto detect_from_fdt;\n\n\tpinfo = spinand_match_id(m, id);\n\tif (pinfo)\n\t\tgoto detect;\n\ndetect_from_fdt:\n\t\tm = spinand_detect_munufacture_from_fdt(chip, id[0]);\n\t\tif (!m)\n\t\t\tgoto not_detect;\n\n\t\tpinfo = spinand_match_id_from_fdt(chip, m, id);\n\t\tif (pinfo)\n\t\t\tgoto detect;\n\nnot_detect:\n\t/* retry without dummy/address@0x00 */\n\tif (dummy) {\n\t\tdummy = 0;\n\t\tgoto retry;\n\t}\n\tpr_info("not match spinand: %x %x\\n",\n\t\t\t*(__u32 *)id,\n\t\t\t*((__u32 *)id + 1));\n\treturn -ENODEV;\ndetect:\n\tpr_info("detect spinand id: %x %x\\n",\n\t\t\t*((__u32 *)pinfo->NandID),\n\t\t\t*((__u32 *)pinfo->NandID + 1));\n\treturn aw_spinand_info_init(chip, pinfo);\n}\n\nMODULE_AUTHOR("liaoweixiong <liaoweixiong@allwinnertech.com>");\nMODULE_DESCRIPTION("Commond physic layer for Allwinner\'s spinand driver");\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u91cd\u65b0\u7f16\u8bd1\u6253\u5305"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"book@100ask:~/tina-v853$ make\n...\nbook@100ask:~/tina-v853$ pack\n...\n"})})]})}function c(t={}){const{wrapper:n}={...(0,_.a)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(s,{...t})}):s(t)}},11151:(t,n,e)=>{e.d(n,{Z:()=>o,a:()=>r});var i=e(67294);const _={},a=i.createContext(_);function r(t){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(_):t.components||_:r(t.components),i.createElement(a.Provider,{value:n},t.children)}}}]);